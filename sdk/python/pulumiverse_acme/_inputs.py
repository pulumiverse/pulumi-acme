# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'CertificateDnsChallengeArgs',
    'CertificateDnsChallengeArgsDict',
    'CertificateHttpChallengeArgs',
    'CertificateHttpChallengeArgsDict',
    'CertificateHttpMemcachedChallengeArgs',
    'CertificateHttpMemcachedChallengeArgsDict',
    'CertificateHttpS3ChallengeArgs',
    'CertificateHttpS3ChallengeArgsDict',
    'CertificateHttpWebrootChallengeArgs',
    'CertificateHttpWebrootChallengeArgsDict',
    'CertificateTlsChallengeArgs',
    'CertificateTlsChallengeArgsDict',
    'RegistrationExternalAccountBindingArgs',
    'RegistrationExternalAccountBindingArgsDict',
]

MYPY = False

if not MYPY:
    class CertificateDnsChallengeArgsDict(TypedDict):
        provider: pulumi.Input[str]
        config: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    CertificateDnsChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateDnsChallengeArgs:
    def __init__(__self__, *,
                 provider: pulumi.Input[str],
                 config: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "provider", provider)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input[str]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "config", value)


if not MYPY:
    class CertificateHttpChallengeArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[int]]
        """
        The port that the challenge server listens on. Default: `80`.
        """
        proxy_header: NotRequired[pulumi.Input[str]]
        """
        The proxy header to match against. Default:
        `Host`.

        The `proxy_header` option behaves differently depending on its definition:

        * When set to `Host`, standard host header validation is used.
        * When set to `Forwarded`, the server looks in the `Forwarded` header for a
        section matching `host=DOMAIN` where `DOMAIN` is the domain currently being
        resolved by the challenge. See [RFC 7239](https://tools.ietf.org/html/rfc7239)
        for more details.
        * When set to an arbitrary header (example: `X-Forwarded-Host`), that header is
        checked for the host entry in the same way the host header would normally be
        checked.
        """
elif False:
    CertificateHttpChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateHttpChallengeArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None,
                 proxy_header: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] port: The port that the challenge server listens on. Default: `80`.
        :param pulumi.Input[str] proxy_header: The proxy header to match against. Default:
               `Host`.
               
               The `proxy_header` option behaves differently depending on its definition:
               
               * When set to `Host`, standard host header validation is used.
               * When set to `Forwarded`, the server looks in the `Forwarded` header for a
               section matching `host=DOMAIN` where `DOMAIN` is the domain currently being
               resolved by the challenge. See [RFC 7239](https://tools.ietf.org/html/rfc7239)
               for more details.
               * When set to an arbitrary header (example: `X-Forwarded-Host`), that header is
               checked for the host entry in the same way the host header would normally be
               checked.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if proxy_header is not None:
            pulumi.set(__self__, "proxy_header", proxy_header)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port that the challenge server listens on. Default: `80`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="proxyHeader")
    def proxy_header(self) -> Optional[pulumi.Input[str]]:
        """
        The proxy header to match against. Default:
        `Host`.

        The `proxy_header` option behaves differently depending on its definition:

        * When set to `Host`, standard host header validation is used.
        * When set to `Forwarded`, the server looks in the `Forwarded` header for a
        section matching `host=DOMAIN` where `DOMAIN` is the domain currently being
        resolved by the challenge. See [RFC 7239](https://tools.ietf.org/html/rfc7239)
        for more details.
        * When set to an arbitrary header (example: `X-Forwarded-Host`), that header is
        checked for the host entry in the same way the host header would normally be
        checked.
        """
        return pulumi.get(self, "proxy_header")

    @proxy_header.setter
    def proxy_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_header", value)


if not MYPY:
    class CertificateHttpMemcachedChallengeArgsDict(TypedDict):
        hosts: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    CertificateHttpMemcachedChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateHttpMemcachedChallengeArgs:
    def __init__(__self__, *,
                 hosts: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "hosts", hosts)

    @property
    @pulumi.getter
    def hosts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "hosts", value)


if not MYPY:
    class CertificateHttpS3ChallengeArgsDict(TypedDict):
        s3_bucket: pulumi.Input[str]
        """
        The s3_bucket to publish the record to.
        """
elif False:
    CertificateHttpS3ChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateHttpS3ChallengeArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input[str]):
        """
        :param pulumi.Input[str] s3_bucket: The s3_bucket to publish the record to.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[str]:
        """
        The s3_bucket to publish the record to.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket", value)


if not MYPY:
    class CertificateHttpWebrootChallengeArgsDict(TypedDict):
        directory: pulumi.Input[str]
        """
        The directory to publish the record to.
        """
elif False:
    CertificateHttpWebrootChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateHttpWebrootChallengeArgs:
    def __init__(__self__, *,
                 directory: pulumi.Input[str]):
        """
        :param pulumi.Input[str] directory: The directory to publish the record to.
        """
        pulumi.set(__self__, "directory", directory)

    @property
    @pulumi.getter
    def directory(self) -> pulumi.Input[str]:
        """
        The directory to publish the record to.
        """
        return pulumi.get(self, "directory")

    @directory.setter
    def directory(self, value: pulumi.Input[str]):
        pulumi.set(self, "directory", value)


if not MYPY:
    class CertificateTlsChallengeArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[int]]
        """
        The port that the challenge server listens on. Default: `443`.
        """
elif False:
    CertificateTlsChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CertificateTlsChallengeArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] port: The port that the challenge server listens on. Default: `443`.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port that the challenge server listens on. Default: `443`.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RegistrationExternalAccountBindingArgsDict(TypedDict):
        hmac_base64: pulumi.Input[str]
        key_id: pulumi.Input[str]
elif False:
    RegistrationExternalAccountBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistrationExternalAccountBindingArgs:
    def __init__(__self__, *,
                 hmac_base64: pulumi.Input[str],
                 key_id: pulumi.Input[str]):
        pulumi.set(__self__, "hmac_base64", hmac_base64)
        pulumi.set(__self__, "key_id", key_id)

    @property
    @pulumi.getter(name="hmacBase64")
    def hmac_base64(self) -> pulumi.Input[str]:
        return pulumi.get(self, "hmac_base64")

    @hmac_base64.setter
    def hmac_base64(self, value: pulumi.Input[str]):
        pulumi.set(self, "hmac_base64", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_id", value)


